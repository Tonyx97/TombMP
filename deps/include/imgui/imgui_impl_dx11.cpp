#include "imgui.h"
#include "imgui_impl_dx11.h"

#include <stdio.h>
#include <string>
#include <d3d11.h>

struct BACKUP_DX11_STATE
{
    UINT ScissorRectsCount;
    D3D11_RECT ScissorRects[D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE];
    ID3D11RasterizerState* RS;
    ID3D11BlendState* BlendState;
    FLOAT BlendFactor[4];
    UINT SampleMask;
    UINT StencilRef;
    ID3D11DepthStencilState* DepthStencilState;
    ID3D11ShaderResourceView* PSShaderResource;
    ID3D11SamplerState* PSSampler;
    ID3D11PixelShader* PS;
    ID3D11VertexShader* VS;
    UINT PSInstancesCount = 256, VSInstancesCount = 256;
    ID3D11ClassInstance* PSInstances[256], * VSInstances[256];
    D3D11_PRIMITIVE_TOPOLOGY PrimitiveTopology;
    ID3D11Buffer* IndexBuffer, * VertexBuffer, * VSConstantBuffer;
    UINT IndexBufferOffset, VertexBufferStride, VertexBufferOffset;
    DXGI_FORMAT IndexBufferFormat;
    ID3D11InputLayout* InputLayout;
};

struct VERTEX_CONSTANT_BUFFER
{
    float mvp[4][4];
};

ID3D11Device* g_device = nullptr;
ID3D11DeviceContext* g_dev_ctx = nullptr;
ID3D11RenderTargetView* g_rtv = nullptr;
ID3D11Buffer* g_vb = nullptr;
ID3D11Buffer* g_ib = nullptr;
ID3D11VertexShader* g_vertex_shader = nullptr;
ID3D11InputLayout* g_input_layout = nullptr;
ID3D11Buffer* g_vertex_const_buffer = nullptr;
ID3D11PixelShader* g_pixel_shader = nullptr;
ID3D11SamplerState* g_font_sampler = nullptr;
ID3D11ShaderResourceView* g_font_texture_view = nullptr;
ID3D11RasterizerState* g_rasterizer_state = nullptr;
ID3D11BlendState* g_blend_state = nullptr;
ID3D11DepthStencilState* g_depth_stencil_state = nullptr;

int g_vertex_buffer_size = 20000,
    g_index_buffer_size = 30000;

void imgui_render()
{
	auto release_ptr =          [](auto ptr)   { if (ptr) ptr->Release(); };
	auto release_ptr_clear =    [](auto*& ptr)  { if (ptr) { ptr->Release(); ptr = nullptr; } };

	ImDrawData* draw_data = ImGui::GetDrawData();

	ImVec4 clear_color = ImVec4(0.f, 0.f, 0.f, 0.f);

	g_dev_ctx->OMSetRenderTargets(1, &g_rtv, nullptr);
	g_dev_ctx->ClearRenderTargetView(g_rtv, (float*)&clear_color);

	if (!g_vb || g_vertex_buffer_size < draw_data->TotalVtxCount)
	{
		release_ptr_clear(g_vb);

		D3D11_BUFFER_DESC desc { 0 };

		desc.Usage = D3D11_USAGE_DYNAMIC;
		desc.ByteWidth = (g_vertex_buffer_size = draw_data->TotalVtxCount + 1) * sizeof(ImDrawVert);
		desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		desc.MiscFlags = 0;

		if (g_device->CreateBuffer(&desc, nullptr, &g_vb) < 0)
			return;
	}

	if (!g_ib || g_index_buffer_size < draw_data->TotalIdxCount)
	{
		release_ptr_clear(g_ib);

		D3D11_BUFFER_DESC desc { 0 };

		desc.Usage = D3D11_USAGE_DYNAMIC;
		desc.ByteWidth = (g_index_buffer_size = draw_data->TotalIdxCount + 1) * sizeof(ImDrawIdx);
		desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
		desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

		if (g_device->CreateBuffer(&desc, nullptr, &g_ib) < 0)
			return;
	}

	D3D11_MAPPED_SUBRESOURCE vtx_resource,
								idx_resource;

	if (g_dev_ctx->Map(g_vb, 0, D3D11_MAP_WRITE_DISCARD, 0, &vtx_resource) != S_OK)
		return;

	if (g_dev_ctx->Map(g_ib, 0, D3D11_MAP_WRITE_DISCARD, 0, &idx_resource) != S_OK)
		return;

	ImDrawVert* vtx_dst = (ImDrawVert*)vtx_resource.pData;
	ImDrawIdx* idx_dst = (ImDrawIdx*)idx_resource.pData;

	for (int n = 0; n < draw_data->CmdListsCount; ++n)
	{
		const ImDrawList* cmd_list = draw_data->CmdLists[n];

		memcpy(vtx_dst, cmd_list->VtxBuffer.Data, cmd_list->VtxBuffer.Size * sizeof(ImDrawVert));
		memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));

		vtx_dst += cmd_list->VtxBuffer.Size;
		idx_dst += cmd_list->IdxBuffer.Size;
	}

	g_dev_ctx->Unmap(g_vb, 0);
	g_dev_ctx->Unmap(g_ib, 0);

	{
		D3D11_MAPPED_SUBRESOURCE mapped_resource;

		if (g_dev_ctx->Map(g_vertex_const_buffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped_resource) != S_OK)
			return;

		VERTEX_CONSTANT_BUFFER* constant_buffer = (VERTEX_CONSTANT_BUFFER*)mapped_resource.pData;

		float L = draw_data->DisplayPos.x;
		float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;
		float T = draw_data->DisplayPos.y;
		float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;

		float mvp[4][4] =
		{
			{ 2.f / (R - L),        0.f,                0.f,       0.f },
			{ 0.f,                  2.f / (T - B),      0.f,       0.f },
			{ 0.f,                  0.f,                0.5f,      0.f },
			{ (R + L) / (L - R),    (T + B) / (B - T),  0.5f,      1.f },
		};

		memcpy(&constant_buffer->mvp, mvp, sizeof(mvp));

		g_dev_ctx->Unmap(g_vertex_const_buffer, 0);
	}

	static D3D11_VIEWPORT viewports[D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE] {};
	static UINT viewports_num = 0;

	BACKUP_DX11_STATE old {};

	old.ScissorRectsCount = D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;

	if (viewports_num == 0)
	{
		viewports_num = D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;
		g_dev_ctx->RSGetViewports(&viewports_num, viewports);
	}

	g_dev_ctx->RSGetScissorRects(&old.ScissorRectsCount, old.ScissorRects);
	g_dev_ctx->RSGetState(&old.RS);
	g_dev_ctx->OMGetBlendState(&old.BlendState, old.BlendFactor, &old.SampleMask);
	g_dev_ctx->OMGetDepthStencilState(&old.DepthStencilState, &old.StencilRef);
	g_dev_ctx->PSGetShaderResources(0, 1, &old.PSShaderResource);
	g_dev_ctx->PSGetSamplers(0, 1, &old.PSSampler);
	g_dev_ctx->PSGetShader(&old.PS, old.PSInstances, &old.PSInstancesCount);
	g_dev_ctx->VSGetShader(&old.VS, old.VSInstances, &old.VSInstancesCount);
	g_dev_ctx->VSGetConstantBuffers(0, 1, &old.VSConstantBuffer);
	g_dev_ctx->IAGetPrimitiveTopology(&old.PrimitiveTopology);
	g_dev_ctx->IAGetIndexBuffer(&old.IndexBuffer, &old.IndexBufferFormat, &old.IndexBufferOffset);
	g_dev_ctx->IAGetVertexBuffers(0, 1, &old.VertexBuffer, &old.VertexBufferStride, &old.VertexBufferOffset);
	g_dev_ctx->IAGetInputLayout(&old.InputLayout);

	D3D11_VIEWPORT vp { 0 };

	vp.Width =  draw_data->DisplaySize.x;
	vp.Height = draw_data->DisplaySize.y;
	vp.MinDepth = 0.f;
	vp.MaxDepth = 1.f;
	vp.TopLeftX = vp.TopLeftY = 0;

	unsigned int stride = sizeof(ImDrawVert);
	unsigned int offset = 0;

	static const float blend_factor[4] = { 0.f, 0.f, 0.f, 0.f };
	
	g_dev_ctx->RSSetViewports(1, &vp);
	g_dev_ctx->IASetInputLayout(g_input_layout);
	g_dev_ctx->IASetVertexBuffers(0, 1, &g_vb, &stride, &offset);
	g_dev_ctx->IASetIndexBuffer(g_ib, sizeof(ImDrawIdx) == 2 ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT, 0);
	g_dev_ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	g_dev_ctx->VSSetShader(g_vertex_shader, nullptr, 0);
	g_dev_ctx->VSSetConstantBuffers(0, 1, &g_vertex_const_buffer);
	g_dev_ctx->PSSetShader(g_pixel_shader, nullptr, 0);
	g_dev_ctx->PSSetSamplers(0, 1, &g_font_sampler);

	g_dev_ctx->OMSetBlendState(g_blend_state, blend_factor, 0xFFFFFFFF);
	g_dev_ctx->OMSetDepthStencilState(g_depth_stencil_state, 0);
	g_dev_ctx->RSSetState(g_rasterizer_state);

	int vtx_offset = 0,
		idx_offset = 0;

	ImVec2 pos = draw_data->DisplayPos;

	for (int n = 0; n < draw_data->CmdListsCount; n++)
	{
		const ImDrawList* cmd_list = draw_data->CmdLists[n];

		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		{
			const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];

			if (pcmd->UserCallback)
				pcmd->UserCallback(cmd_list, pcmd);
			else
			{
				const D3D11_RECT r = { (LONG)(pcmd->ClipRect.x - pos.x), (LONG)(pcmd->ClipRect.y - pos.y), (LONG)(pcmd->ClipRect.z - pos.x), (LONG)(pcmd->ClipRect.w - pos.y) };

				ID3D11ShaderResourceView* texture_srv = (ID3D11ShaderResourceView*)pcmd->TextureId;

				g_dev_ctx->RSSetScissorRects(1, &r);
				g_dev_ctx->PSSetShaderResources(0, 1, &texture_srv);
				g_dev_ctx->DrawIndexed(pcmd->ElemCount, idx_offset, vtx_offset);
			}

			idx_offset += pcmd->ElemCount;
		}

		vtx_offset += cmd_list->VtxBuffer.Size;
	}

	g_dev_ctx->RSSetScissorRects(old.ScissorRectsCount, old.ScissorRects);
	g_dev_ctx->RSSetViewports(viewports_num, viewports);
	g_dev_ctx->RSSetState(old.RS);                                                                                release_ptr(old.RS);
	g_dev_ctx->OMSetBlendState(old.BlendState, old.BlendFactor, old.SampleMask);                                  release_ptr(old.BlendState);
	g_dev_ctx->OMSetDepthStencilState(old.DepthStencilState, old.StencilRef);                                     release_ptr(old.DepthStencilState);
	g_dev_ctx->PSSetShaderResources(0, 1, &old.PSShaderResource);                                                 release_ptr(old.PSShaderResource);
	g_dev_ctx->PSSetSamplers(0, 1, &old.PSSampler);                                                               release_ptr(old.PSSampler);
	g_dev_ctx->PSSetShader(old.PS, old.PSInstances, old.PSInstancesCount);                                        release_ptr(old.PS);

	for (auto i = 0u; i < old.PSInstancesCount; ++i)
		release_ptr(old.PSInstances[i]);

	g_dev_ctx->VSSetShader(old.VS, old.VSInstances, old.VSInstancesCount);                                        release_ptr(old.VS);

	for (auto i = 0u; i < old.VSInstancesCount; ++i)
		release_ptr(old.VSInstances[i]);

	g_dev_ctx->VSSetConstantBuffers(0, 1, &old.VSConstantBuffer);                                                 release_ptr(old.VSConstantBuffer);
	g_dev_ctx->IASetPrimitiveTopology(old.PrimitiveTopology);
	g_dev_ctx->IASetIndexBuffer(old.IndexBuffer, old.IndexBufferFormat, old.IndexBufferOffset);                   release_ptr(old.IndexBuffer);
	g_dev_ctx->IASetVertexBuffers(0, 1, &old.VertexBuffer, &old.VertexBufferStride, &old.VertexBufferOffset);     release_ptr(old.VertexBuffer);
	g_dev_ctx->IASetInputLayout(old.InputLayout);                                                                 release_ptr(old.InputLayout);
}

void imgui_destroy()
{
	if (g_font_sampler)			{ g_font_sampler->Release();		g_font_sampler = nullptr; }
	if (g_font_texture_view)	{ g_font_texture_view->Release();	g_font_texture_view = nullptr; ImGui::GetIO().Fonts->SetTexID(nullptr); }
	if (g_ib)					{ g_ib->Release();					g_ib = nullptr; }
	if (g_vb)					{ g_vb->Release();					g_vb = nullptr; }
	if (g_blend_state)			{ g_blend_state->Release();			g_blend_state = nullptr; }
	if (g_depth_stencil_state)	{ g_depth_stencil_state->Release(); g_depth_stencil_state = nullptr; }
	if (g_pixel_shader)			{ g_pixel_shader->Release();		g_pixel_shader = nullptr; }
	if (g_vertex_const_buffer)	{ g_vertex_const_buffer->Release(); g_vertex_const_buffer = nullptr; }
	if (g_input_layout)			{ g_input_layout->Release();		g_input_layout = nullptr; }
	if (g_vertex_shader)		{ g_vertex_shader->Release();		g_vertex_shader = nullptr; }
	if (g_device)				{ g_device->Release();				g_device = nullptr; }
	if (g_dev_ctx)				{ g_dev_ctx->Release();				g_dev_ctx = nullptr; }

	ImGui::DestroyContext();
}

void imgui_create_font()
{
    ImGuiIO& io = ImGui::GetIO();

    unsigned char* pixels;

    int width,
        height;

    io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

    {
        D3D11_TEXTURE2D_DESC desc { 0 };

        desc.Width = width;
        desc.Height = height;
        desc.MipLevels = 1;
        desc.ArraySize = 1;
        desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        desc.SampleDesc.Count = 1;
        desc.Usage = D3D11_USAGE_DEFAULT;
        desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        desc.CPUAccessFlags = 0;

        ID3D11Texture2D* texture = nullptr;
        D3D11_SUBRESOURCE_DATA sub_resc;

        sub_resc.pSysMem = pixels;
        sub_resc.SysMemPitch = desc.Width * 4;
        sub_resc.SysMemSlicePitch = 0;

		g_device->CreateTexture2D(&desc, &sub_resc, &texture);

        D3D11_SHADER_RESOURCE_VIEW_DESC srv_desc;

        memset(&srv_desc, 0, sizeof(srv_desc));

        srv_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
        srv_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
        srv_desc.Texture2D.MipLevels = desc.MipLevels;
        srv_desc.Texture2D.MostDetailedMip = 0;

		g_device->CreateShaderResourceView(texture, &srv_desc, &g_font_texture_view);

        texture->Release();
    }

    io.Fonts->TexID = (ImTextureID)g_font_texture_view;

    {
        D3D11_SAMPLER_DESC desc;

        memset(&desc, 0, sizeof(desc));

        desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
        desc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
        desc.MipLODBias = 0.f;
        desc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
        desc.MinLOD = 0.f;
        desc.MaxLOD = 0.f;

		g_device->CreateSamplerState(&desc, &g_font_sampler);
    }
}

bool imgui_create_device_objs()
{
    if (!g_device)
        return false;

	static unsigned char g_vertex_shader_blob[] = 
	{
		0x44, 0x58, 0x42, 0x43, 0xfd, 0xcd, 0x22, 0xeb, 0x8c, 0x14, 0x1d, 0x9c, 0xcd, 0xe7, 0x7c, 0x70, 0xb0, 0x51, 0xe, 0xd2, 0x1, 0x0, 0x0, 0x0, 0x78, 0x3, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0x10, 0x1, 0x0, 0x0, 0x80, 0x1, 0x0, 0x0, 0xf4, 0x1, 0x0, 0x0, 0xfc, 0x2, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xd4, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x4c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xfe, 0xff, 0x0, 0x1, 0x0, 0x0, 0xa0, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x76, 0x65, 0x72, 0x74, 0x65, 0x78, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x0, 0xab, 0xab, 0xab, 0x3c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x64, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x0, 0xab, 0xab, 0xab, 0x3, 0x0, 0x3, 0x0, 0x4, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x0, 0xab, 0xab, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x68, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x59, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0xf, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0x4f, 0x53, 0x47, 0x4e, 0x6c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x62, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0x53, 0x48, 0x44, 0x52, 0x0, 0x1, 0x0, 0x0, 0x40, 0x0, 0x1, 0x0, 0x40, 0x0, 0x0, 0x0, 0x59, 0x0, 0x0, 0x4, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0xf2, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x5f, 0x0, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x67, 0x0, 0x0, 0x4, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0x32, 0x20, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x8, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x56, 0x15, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x32, 0x0, 0x0, 0xa, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x8e, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0xf2, 0x20, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x46, 0x1e, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x36, 0x0, 0x0, 0x5, 0x32, 0x20, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	};

    static unsigned char g_pixel_shader_blob[] =
    {
        0x44, 0x58, 0x42, 0x43, 0xe0, 0x8e, 0x7f, 0xfa, 0x43, 0xb1, 0x5e, 0xd0, 0xa4, 0xff, 0x2, 0x13, 0x2a, 0xd8, 0xc, 0x7a, 0x1, 0x0, 0x0, 0x0, 0x9c, 0x2, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x34, 0x0, 0x0, 0x0, 0xdc, 0x0, 0x0, 0x0, 0x50, 0x1, 0x0, 0x0, 0x84, 0x1, 0x0, 0x0, 0x20, 0x2, 0x0, 0x0, 0x52, 0x44, 0x45, 0x46, 0xa0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0, 0x4, 0xff, 0xff, 0x0, 0x1, 0x0, 0x0, 0x6e, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x5, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xc, 0x0, 0x0, 0x0, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x72, 0x30, 0x0, 0x74, 0x65, 0x78, 0x74, 0x75, 0x72, 0x65, 0x30, 0x0, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4c, 0x53, 0x4c, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x65, 0x72, 0x20, 0x39, 0x2e, 0x32, 0x39, 0x2e, 0x39, 0x35, 0x32, 0x2e, 0x33, 0x31, 0x31, 0x31, 0x0, 0xab, 0x49, 0x53, 0x47, 0x4e, 0x6c, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x5c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf, 0xf, 0x0, 0x0, 0x62, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3, 0x3, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x50, 0x4f, 0x53, 0x49, 0x54, 0x49, 0x4f, 0x4e, 0x0, 0x43, 0x4f, 0x4c, 0x4f, 0x52, 0x0, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x4f, 0x52, 0x44, 0x0, 0xab, 0x4f, 0x53, 0x47, 0x4e, 0x2c, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0x0, 0x0, 0x53, 0x56, 0x5f, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x0, 0xab, 0xab, 0x53, 0x48, 0x44, 0x52, 0x94, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x25, 0x0, 0x0, 0x0, 0x5a, 0x0, 0x0, 0x3, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x18, 0x0, 0x4, 0x0, 0x70, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x55, 0x55, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0xf2, 0x10, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x62, 0x10, 0x0, 0x3, 0x32, 0x10, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x65, 0x0, 0x0, 0x3, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x68, 0x0, 0x0, 0x2, 0x1, 0x0, 0x0, 0x0, 0x45, 0x0, 0x0, 0x9, 0xf2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x10, 0x10, 0x0, 0x2, 0x0, 0x0, 0x0, 0x46, 0x7e, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x0, 0x0, 0x7, 0xf2, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0xe, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46, 0x1e, 0x10, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x1, 0x53, 0x54, 0x41, 0x54, 0x74, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    };

    if (g_device->CreateVertexShader((DWORD*)g_vertex_shader_blob, sizeof(g_vertex_shader_blob), nullptr, &g_vertex_shader) != S_OK)
        return false;
   
    if (g_device->CreatePixelShader((DWORD*)g_pixel_shader_blob, sizeof(g_pixel_shader_blob), nullptr, &g_pixel_shader) != S_OK)
        return false;

    D3D11_INPUT_ELEMENT_DESC local_layout[] =
    {
        { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT,   0, (size_t)(&((ImDrawVert*)0)->pos), D3D11_INPUT_PER_VERTEX_DATA, 0 },
        { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,   0, (size_t)(&((ImDrawVert*)0)->uv),  D3D11_INPUT_PER_VERTEX_DATA, 0 },
        { "COLOR",    0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, (size_t)(&((ImDrawVert*)0)->col), D3D11_INPUT_PER_VERTEX_DATA, 0 },
    };
    
    if (g_device->CreateInputLayout(local_layout, 3, g_vertex_shader_blob, sizeof(g_vertex_shader_blob), &g_input_layout) != S_OK)
        return false;

    {
        D3D11_BUFFER_DESC desc { 0 };

        desc.ByteWidth = sizeof(VERTEX_CONSTANT_BUFFER);
        desc.Usage = D3D11_USAGE_DYNAMIC;
        desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
        desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
        desc.MiscFlags = 0;

		g_device->CreateBuffer(&desc, nullptr, &g_vertex_const_buffer);
    }

    {
        D3D11_BLEND_DESC desc { 0 };

        desc.AlphaToCoverageEnable = false;
        desc.RenderTarget[0].BlendEnable = true;
        desc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
        desc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
        desc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
        desc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_INV_DEST_ALPHA;
        desc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ONE;
        desc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
        desc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;

		g_device->CreateBlendState(&desc, &g_blend_state);
    }

    {
        D3D11_RASTERIZER_DESC desc;

        memset(&desc, 0, sizeof(desc));

        desc.FillMode = D3D11_FILL_SOLID;
        desc.CullMode = D3D11_CULL_NONE;
        desc.ScissorEnable = true;
        desc.DepthClipEnable = true;

		g_device->CreateRasterizerState(&desc, &g_rasterizer_state);
    }

    {
        D3D11_DEPTH_STENCIL_DESC desc { 0 };

        desc.DepthEnable = false;
        desc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
        desc.DepthFunc = D3D11_COMPARISON_ALWAYS;
        desc.StencilEnable = false;
        desc.FrontFace.StencilFailOp = desc.FrontFace.StencilDepthFailOp = desc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
        desc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
        desc.BackFace = desc.FrontFace;

		g_device->CreateDepthStencilState(&desc, &g_depth_stencil_state);
    }

    imgui_create_font();

    return true;
}

bool init_imgui_renderer(IDXGISwapChain* sc, const char* font, float sx, float sy)
{
    sc->GetDevice(__uuidof(ID3D11Device), (void**)&g_device);

	g_device->GetImmediateContext(&g_dev_ctx);

    ID3D11Texture2D* local_rtv = nullptr;

    if (SUCCEEDED(sc->GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)&local_rtv)))
    {
		g_device->CreateRenderTargetView(local_rtv, nullptr, &g_rtv);
        local_rtv->Release();
    }

    ImGui::CreateContext();
    ImGui::StyleColorsDark();

    ImGuiIO& io = ImGui::GetIO();

    io.KeySuper = false;
    io.BackendRendererName = "";
    io.BackendPlatformName = "";
    io.ImeWindowHandle = nullptr;
	io.DisplaySize = { sx, sy };
	io.IniFilename = nullptr;
	io.LogFilename = nullptr;
    
	io.Fonts->AddFontFromFileTTF((std::string("data\\fonts\\") + font).c_str(), 16.f, nullptr, io.Fonts->GetGlyphRangesDefault());

    return imgui_create_device_objs();
}